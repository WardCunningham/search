<html>
<head>
  <meta charset="UTF-8">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“˜</text></svg>">
  <script src="https://unpkg.com/@hpcc-js/wasm@1.20.1/dist/index.min.js"></script>
  <script> var hpccWasm = window["@hpcc-js/wasm"]; </script>
  <script src="https://cdn.jsdelivr.net/gh/dash14/svg-pan-zoom/dist/svg-pan-zoom.min.js"></script>
</head>
<body>

<style>

  html, body, main { width: 100vw; height: 100vh; margin: 0;}
  main {
    display: grid;
    grid-template-areas:
      "beam   target"
      "create target";
    grid-template-columns: 1fr 5fr;
    grid-template-rows: 3fr 1fr;
  }
  #beam   {grid-area:beam; background-color:palegreen;}
  #create {grid-area:create; background-color:bisque;}
  #target {grid-area:target; overflow:scroll;}
  #beam, #create {
    margin:4px;
    padding:8px;
    overflow-y: scroll;
  }
  #beam input, label {cursor:pointer;}
</style>

<main>
  <div id="beam" ondrop="drop(event)" ondragover="over(event)" ondragenter="over(event)">
    <div id="beamlist" onchange="dochoose(event)"></div>
  </div>
  <div id="target" ondrop="drop(event)" ondragover="over(event)" ondragenter="over(event)">
  </div>
  <div id="create" ondrop="drop(event)" ondragover="over(event)" ondragenter="over(event)">
    <div style="padding:16px; font-size:large;">Learn more about<br>
      <a href=http://search.dojo.fed.wiki/solo-super-collaborator.html target=_blank>
        Browsing Relations</a>
    </div>
  </div>
<!--   <div id=floater style="position:absolute; border:1px solid; background-color:white; overflow-wrap:break-word; padding:4px; width:200px; height:200px;" data-cid="" hidden>
    <svg viewBox="0 0 100 100">
      <polyline
        id="grid"
        points="0,0 0,100 100,100 100,0 0,0"
        stroke="#ccc" fill="none"/>
      <polyline
        id="growing"
        points="100,100"
        fill="none"
        stroke="brown"
        stroke-width=".5"
        stroke-linejoin="round"/>
    </svg>
    <div id=controls></div>
  </div> -->
</main>

<!-- <script src="https://unpkg.com/@croquet/croquet"></script> -->
<script type=module>

  const croquet = {}

  // import {Graph} from './graph.js'
  // import {drop,dropl,dropu} from './drop.js'
  // import {composite} from './composite.js'
  // import {dotify} from './dotify.js'
  // import {hoverbold} from './hoverbold.js'
  // import * as injector from './create.js'
  // import {BeamModel, BeamView, croquet} from './beam.js'
  // import * as sim from './sim.js'

  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms))

  const creating = {
    index: -1,
    start: (graph) => {
      creating.index = croquet.view.beam().length
      croquet.view.newPoems([{name:graph.nodes[0].type+'â‹¯',graph}])
    },
    update: (graph) => {
      croquet.view.updatePoem(creating.index, graph, 'â‹¯')
    },
    finish: (graph) => {
      croquet.view.updatePoem(creating.index, graph, '')
      creating.index = -1
    }
  }
  // injector.create(window.create, creating)

  window.over = function (event) {
    event.preventDefault()
  }

  window.drop = async function (event) {
    event.preventDefault();
    switch (event.target.closest('div[ondrop]').id) {
      case "beam":
        const poems = [
          ...await dropl(event, '.jsonl'),
          ...await drop(event, '.graph.json'),
          ...await dropu(event)
        ]
        for (const poem of poems) {
          croquet.view.newPoems([poem])
          await delay(60)
          console.log('poem',poem)
        }
        break
      case "create":
        injector.schema((await drop(event, '.schema.json'))[0].graph)
        injector.create(window.create, creating)
        break
      case "target":
        const poemz = [
          ...await dropl(event, '.jsonl'),
          ...await drop(event, '.graph.json')
        ]
        const json = composite(poemz).graph.stringify(null,2)
        croquet.view.nextdownload = [json, 'target.graph.json', 'application/json']
        display(poemz)
        recommend(poemz)
        break
      default:
        console.log('Failed to dispatch', event.target)
    }
  }

  // let event = new CustomEvent('target', {detail:{nodes,rels}})
  // window.dispatchEvent(event)
  const inst = ({nodes,rels}) => {return new Graph(nodes, rels)}
  window.addEventListener('target',event => {
    const graph = inst(event.detail)
    croquet.view.nextdownload = [graph.stringify(null,2), 'target.graph.json', 'application/json']
    display([{name:'target',graph}])
  })


  window.dochoose = function (event) {
    croquet.view.nextdownload = null
    const checked = [...window.beam.querySelectorAll('input[type=checkbox]:checked')]
    const beam = croquet.view.beam()
    const chosen = checked.map(e => Object.assign({index:e.value},beam[e.value]))
    display(chosen)
    recommend(chosen)
  }

  function recommend(chosen) {
    const vocabulary = new Set()
    const hash = node => `${node.type}: ${node.props.name || ''}`
    for (const poem of chosen) {
      for (const node of poem.graph.nodes) {
        vocabulary.add(hash(node))
      }
    }
    const similar = graph => {
      for (const node of graph.nodes) {
        if (vocabulary.has(hash(node))) return true
      }
      return false
    }
    const beam = croquet.view.beam()
    window.beam.querySelectorAll('input[type=checkbox]').forEach(elem => {
      const color = !elem.checked && similar(beam[elem.value].graph) ? 'darkorange' : 'black'
      elem.nextElementSibling.style.color = color
    })
  }

  let drawing = false
  // let siminterval = null
  let panSVG = null
  const panZoom = {}
  async function display(chosen) {
    if(!drawing){
      drawing = true
      // if (siminterval) clearInterval(siminterval)
      // floater.hidden = true
      const complex = composite(chosen)
      try {
        if (document.querySelector('#target svg')) {
          panZoom.pan = panSVG.getPan()
          panZoom.zoom = panSVG.getZoom()
          panZoom.size = { 
              width: document.querySelector('#target svg').width.baseVal.valueInSpecifiedUnits, 
              height: document.querySelector('#target svg').height.baseVal.valueInSpecifiedUnits
            }
        }
        const dot = dotify(complex)
        window.dot = dot
        hpccWasm.graphviz.layout(window.dot, "svg", "dot").then(svg => {
          target.innerHTML = svg;
          drawing = false
          hoverbold(target)
          const targetBounds = { width: document.querySelector('#target').clientWidth, height: document.querySelector('#target').clientHeight } 
          const svgBounds = { width: document.querySelector('#target svg').clientWidth, height: document.querySelector('#target svg').clientHeight }
          let svgElement = document.querySelector('#target svg')
          panSVG = svgPanZoom(svgElement)
          document.querySelector('#target svg').style.height = "100%"
          document.querySelector('#target svg').style.width = "100%"
          if (targetBounds.width < svgBounds.width || targetBounds.height < svgBounds.height) {
            panSVG.resize()
          }
          panSVG.fit()
          panSVG.center()
          if (panZoom.size && 
              panZoom.size.width == document.querySelector('#target svg').width.baseVal.valueInSpecifiedUnits &&
              panZoom.size.height == document.querySelector('#target svg').height.baseVal.valueInSpecifiedUnits) {
            panSVG.zoom(panZoom.zoom)
            panSVG.pan(panZoom.pan)
          }
        })
      } catch (err) {
        console.log('display error', err)
        drawing = false
      }
      await delay(500);
      const nodes = Object.fromEntries([...target.querySelectorAll('.node')]
        .map(node => [node.querySelector('title').textContent,node]))
      const neq = (a,b) => a.type == b.type && a.props.name == b.props.name
      const name = node => `${node.type}:${node.props.name}`
      for(const cid in nodes){
        if(complex.graph.nodes[cid].type != 'Variable') break
        nodes[cid].addEventListener('click',event => {
          event.preventDefault()
          event.stopPropagation()
          const picks = chosen.filter(entry =>
            entry.graph.nodes.find(node =>
              neq(node, complex.graph.nodes[cid])))
          const pick = picks[0]
          const nid = pick.graph.nodes.findIndex(node => neq(node,complex.graph.nodes[cid]))
          const g = complex.graph
          const n = g.nodes[cid]
          console.log(pick.index, pick.name, cid, nid, name(n))
          window.props = complex.graph.nodes[cid].props
          window.save = () => croquet.view.updatePoem(pick.index,pick.graph,"*")
          // floater.style.left = event.clientX+5
          // floater.style.top = event.clientY+5
          // growing.setAttribute('points','100,100')
          // floater.dataset.cid = cid
          const slide = () => `<input type=range min=0 max=100 value=50 style="width: 100%">`
          const nslide = (n,p) => n.props.hasOwnProperty(p) ? `${n.props.name} ${p}: <span>${n.props[p]}</span>${slide()}` : ''
          const rslide = (r,rate) => r.props.hasOwnProperty(rate) ? `${r.type} ${rate}: <span>${r.props[rate]}</span>${slide()}` : ''
          controls.innerHTML = `<p>
            ${['wax','wane'].map(p => nslide(n,p)).join('')}
            ${n.in.map(rid => {const r = g.rels[rid]; return rslide(r,'orate')}).join('')}
            ${n.out.map(rid => {const r = g.rels[rid]; return rslide(r,'irate')}).join('')}
          `
          // floater.hidden=false
        })
        // nodes[cid].addEventListener('mouseleave',event => {
        //   floater.hidden=true
        // })
      }
      // const tick = (nid,value) => {
      //   if(+(floater.dataset.cid) == +nid) {
      //     let points = growing.getAttribute('points')
      //     let samples = points.split(' ')
      //       .map(pair => {
      //         let [x,y] = pair.split(',')
      //         return [x-1,y].join(',')
      //       })
      //     if (samples.length >= 100) samples.shift()
      //     samples.push([100,100-Math.max(0,Math.min(100,value))].join(','))
      //     growing.setAttribute('points', samples.join(' '))

      //   }
      // }

      // siminterval = sim.start(nodes,complex.graph,tick);
      // [...target.querySelectorAll('a')]
      //   .filter(n=>n.textContent.match(/â˜‘|â˜/))
      //   .map(n => {
      //     n.addEventListener('click',event => {
      //       event.preventDefault()
      //       event.stopPropagation()
      //       const texts = n.querySelectorAll('text')
      //       texts.forEach(text => {
      //         if (text.textContent.match(/â˜/))
      //           text.textContent = text.textContent.replace('â˜','â˜‘')
      //         else
      //           text.textContent = text.textContent.replace('â˜‘','â˜')
      //       })
      //       clearInterval(siminterval)
      //       siminterval = sim.start(nodes,complex.graph,tick)
      //     })
      //   })
    } else {
      console.log('display: skipping', chosen)
    }
  }


  // const session = await Croquet.Session.join({
  //   apiKey: '1MNinyGopbyxFzgx3HupBoCAryFb6yNOIihx6Omx9',
  //   appId: 'com.gmail.ward.cunningham.collaborator',
  //   name: params.name || "unnamed",
  //   password: "secret",
  //   model: BeamModel,
  //   view: BeamView
  // })
  // console.log(session)

// Class Graph

const uniq = (value, index, self) => self.indexOf(value) === index

class Graph {
  constructor(nodes=[], rels=[]) {
    this.nodes = nodes;
    this.rels = rels;
  }

  addNode(type, props={}){
    const obj = {type, in:[], out:[], props};
    this.nodes.push(obj);
    return this.nodes.length-1;
  }

  addRel(type, from, to, props={}) {
    const obj = {type, from, to, props};
    this.rels.push(obj);
    const rid = this.rels.length-1;
    this.nodes[from].out.push(rid)
    this.nodes[to].in.push(rid);
    return rid;
  }

  tally(){
    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});
    return { nodes:tally(this.nodes), rels:tally(this.rels)};
  }

  size(){
    return this.nodes.length + this.rels.length;
  }

  static load(obj) {
    // let obj = await fetch(url).then(res => res.json())
    return new Graph(obj.nodes, obj.rels)
  }

  static async fetch(url) {
    const obj = await fetch(url).then(res => res.json())
    return Graph.load(obj)
  }

  static async read(path) {
    const json = await Deno.readTextFile(path);
    const obj = JSON.parse(json);
    return Graph.load(obj)
  }

  // static async import(path) {
  //   let module = await import(path, {assert: {type: "json"}})
  //   return Graph.load(module.default)
  // }

  n(type=null, props={}) {
    let nids = Object.keys(this.nodes).map(key => +key)
    if (type) nids = nids.filter(nid => this.nodes[nid].type == type)
    for (const key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])
    return new Nodes(this, nids)
  }

  /**
   * Converts a graph to a JavaScript Object Notation (JSON) string using JSON.stringify.
   @param - replacer A function that transforms the results.
   @param - space Adds indentation, white space, and line break characters to the return-
   * @returns {string} JSON string containing serialized graph
  */
  stringify(...args) {
    const obj = { nodes: this.nodes, rels: this.rels }
    return JSON.stringify(obj, ...args)
  }
}


// read named graph files that have been dropped by event

export async function drop (event,sufix) {
  const want = files(event).filter(file =>
    file.name.endsWith(sufix) &&
    file.type === 'application/json')
  const concepts = []
  for (const file of want) {
    const name = file.name.replace(sufix,'')
    const graph = await file.text()
      .then(text => JSON.parse(text))
      .then(inst)
    concepts.push({name, graph})
  }
  return concepts
}

export async function dropl (event,sufix) {
  const want = files(event).filter(file =>
    file.name.endsWith(sufix))
  const concepts = []
  for (const file of want) {
    const text = await file.text()
    text.trim().split(/\n/).forEach(line => {
      const {name,graph} = JSON.parse(line)
      concepts.push({name,graph:inst(graph)})
    })
  }
  return concepts
}

export async function dropu (event) {
  const want = strings(event)
  const concepts = []
  for (const file of want) {
    const filename = await file
    const name = filename.split(/\//).reverse()[0].split(/\./)[0]
    const graph = await fetch(filename)
      .then(res => res.json())
      .then(inst)
    concepts.push({name,graph})
  }
  return concepts
}

function files(event) {
  if (event.dataTransfer.items) {
    return [...event.dataTransfer.items]
      .filter(item => item.kind === 'file')
      .map(item => item.getAsFile())
  } else {
    return [...event.dataTransfer.files]
  }
}

function strings(event) {
  if (event.dataTransfer.items) {
    return [...event.dataTransfer.items]
      .filter(item => item.kind === 'string')
      .filter(item => item.type === 'text/uri-list')
      .map(item => {return new Promise(res => item.getAsString(res))})
  } else {
    return [...event.dataTransfer.files]
  }

}


// aggregate multiple graphs into a single graph

function composite(concepts) {
  const merged = {nids:[]}
  const comp = new Graph()
  for (const concept of concepts) {
    const {name,graph} = concept
    merge(comp,graph,name)
  }
  return {graph:comp, merged}


  function merge(comp,incr,source) {

    function mergeprops(into,from) {
      const keys = Object.keys(into)
        .concat(Object.keys(from))
        .filter(uniq)
      for (const key of keys) {
        if (into[key]) {
          // if (from[key] && into[key] != from[key]) {
          //   window.result.innerHTML +=
          //     `<div style="font-size:small; padding:4px; background-color:#fee; border-radius:4px; border:1px solid #aaa;">
          //       conflict for "${key}" property<br>
          //       choosing "${into[key]}" over "${from[key]}"</div>`
          // }
        }
        else {
          if(from[key]) {
            into[key] = from[key]
          }
        }
      }
    }

    const nids = {}  // incr => comp
    incr.nodes.forEach((node,id) => {
      const match = comp.nodes.find(each =>
        each.type == node.type &&
        each.props.name == node.props.name)
      if(match) {
        // window.result.innerHTML += `Same <b>${match.type}</b> ${match.props.name}<br>`
        nids[id] = comp.nodes.findIndex(node => node === match)
        merged.nids.push(nids[id])
        mergeprops(match.props, node.props)
      } else {
        nids[id] = comp.addNode(node.type,node.props)
      }
    })
    incr.rels.forEach(rel => {
      const match = comp.rels.find(each =>
        each.type == rel.type &&
        each.from == nids[rel.from] &&
        each.to == nids[rel.to]
      )
      if(match) {
        // window.result.innerHTML += `Same
        //   <b>${comp.nodes[match.from].type}</b> ${comp.nodes[match.from].props.name}
        //   <b>${match.type}</b> â–·
        //   ${comp.nodes[match.to].type} ${comp.nodes[match.to].props.name}<br>`
        mergeprops(match.props, rel.props)
      } else {
        rel.props.source = source
        comp.addRel(rel.type, nids[rel.from], nids[rel.to], rel.props)
      }
    })
  }
}


// render graph as dot input to graphviz

function dotify(complex) {
  const inputs = ["read", "get"]

  const {graph, merged} = complex
  const tip = props => Object.entries(props).filter(e => e[1]).map(e => `${e[0]}: ${e[1]}`).join("\\n")

  const layout = graph.nodes
    .filter(node => node.type == 'Graphviz' && node.props.layout)
    .map(node => node.props.layout)
  const emphasis = graph.nodes
    .filter(node => node.type == 'Graphviz' && node.props.emphasis)
    .map(node => node.props.emphasis)
    ?.reverse()[0] || {}
  console.log('dotify',emphasis)

  const nodes = graph.nodes.map((node,id) => {
    const icon = node.props.url ? " ðŸ”—" : node.props.tick ? " â˜" : ""
    const label = `${node.type}\\n${node.props.name}${icon}`
    const color = emphasis[node.type] || ''
    return `${id} [label="${label}" ${color} ${(node.props.url||node.props.tick)?`URL="${node.props.url||'#'}" target="_blank"`:''} tooltip="${tip(node.props)}"]`
  })

      // if inputs.include?r['type']
      //   file.puts "#{r['to']} -> #{r['from']} [#{props} dir=back]"
      // else
      //   file.puts "#{r['from']} -> #{r['to']} [#{props}]"
      // end
 
  const edges = graph.rels.map(rel => {
    const color = emphasis[rel.type] || ''
    if (inputs.includes(rel.type))
      return `${rel.to}->${rel.from} [label="${rel.type}" ${color} labeltooltip="${tip(rel.props)}" dir=back]`
    else
      return `${rel.from}->${rel.to} [label="${rel.type}" ${color} labeltooltip="${tip(rel.props)}"]`
  })
  return [
    'digraph {',
    'overlap = false; splines=true',
    `layout = ${layout.reverse()[0]||'dot'};`,
    'node [shape=box style=filled fillcolor=gold penwidth=2]',
    ...merged.nids,
    'node [fillcolor=palegreen penwidth=1]',
    ...nodes,
    ...edges,
    '}'].join("\n")
}

// embolden lines from graphviz svg nodes on hover

function hoverbold(div,select='both') {
  let rels = [] // [[edge, from, to], ...]
  const title = target => target.querySelector('title').textContent.replace(/\\n/g,' ')
  div.querySelectorAll('.edge').forEach(edge => rels.push([edge, ...title(edge).split('->')]))
  const trace = (node,doit) => {
    console.log()
    const related = io => rels.filter(row => row[io]==node)
    switch (select) {
      case 'output':
        related(1).map(row => doit(row[0]))
        break
      case 'input':
        related(2).map(row => doit(row[0]))
        break
      case 'both':
        related(1).map(row => doit(row[0]))
        related(2).map(row => doit(row[0]))
        break
      case 'most':
        let o = related(1).length
        let i = related(2).length
        related(o>i?1:2).map(row => doit(row[0]))
        break
    }
  }
  const feature = (event,width) => {
    if(width==3) console.log([...event.target.querySelectorAll('text')].map(e => e.innerHTML).join(" "))
  }
  const stroke = width => {
    const adjust = edge => edge.setAttribute('stroke-width',width)
    return event => {feature(event,width); return trace(title(event.target), adjust)}
  }
  div.querySelectorAll('.node').forEach(node => {
    node.addEventListener('mouseenter',stroke(3))
    node.addEventListener('mouseleave',stroke(1))
  })
}



class BeamModel {

  init() {
    this.views = new Map();
    this.participants = 0;
    this.history = []; // { viewId, html } items
    this.beam = []; //{name, graph}
    this.lastPostTime = null;
    this.inactivity_timeout_ms = 60 * 1000 * 20; // constant
    // this.subscribe(this.sessionId, "view-join", this.viewJoin);
    // this.subscribe(this.sessionId, "view-exit", this.viewExit);
    // this.subscribe("input", "newName", this.newName);
    // this.subscribe("input", "newPost", this.newPost);
    // this.subscribe("input", "reset", this.resetHistory);
    // this.subscribe("input", "remove", this.removePoems);
    // this.subscribe("input", "newPoems", this.addToBeam);
    // this.subscribe("input", "updatePoem", this.updatePoem);
    croquet.model = this
  }

  static types() {
    return {
      "Graph": Graph
    };
  }

  viewJoin(viewId) {
    const existing = this.views.get(viewId);
    if (!existing) {
      const nickname = this.randomName();
      this.views.set(viewId, nickname);
    }
    this.participants++;
    this.publish("viewInfo", "refresh");
  }

  viewExit(viewId) {
    this.participants--;
    this.views.delete(viewId);
    this.publish("viewInfo", "refresh");
  }

  newName(opt) {
    this.views.set(opt.viewId, opt.nickname)
    this.publish("viewInfo", "refresh")
  }

  newPost(post) {
    const postingView = post.viewId;
    const nick = this.views.get(postingView);
    const chat = this.escape(post.chat);
    this.addToHistory({ viewId: postingView, nick, chat });
    this.lastPostTime = this.now();
    this.future(this.inactivity_timeout_ms).resetIfInactive();
  }

  updatePoem(opt) {
    const poem = this.beam[opt.index]
    const name = opt.graph.nodes[0].props.name || opt.graph.nodes[0].type || ''
    poem.name = name+opt.suffix
    poem.graph = opt.graph
    this.publish("beam", "refresh")
  }

  removePoems(indices) {
    for (const index of indices.reverse()) {
      this.beam.splice(index,1)
    }
    this.publish("beam", "refresh")
    window.beam.querySelectorAll('input').forEach(e => e.checked = false)
  }

  addToHistory(item){
    this.history.push(item);
    if (this.history.length > 100) this.history.shift();
    this.publish("history", "refresh");
  }

  addToBeam(poems) {
    this.beam.push(...poems)
    // this.publish("beam", "refresh")
    croquet.view.refreshBeam()
  }

  resetIfInactive() {
    if (this.lastPostTime !== this.now() - this.inactivity_timeout_ms) return;
    this.resetHistory("due to inactivity");
  }

  resetHistory(reason) {
    this.history = [{ nick:'system', chat: `reset ${reason}` }];
    if (reason == "at user request") this.beam = []
    this.lastPostTime = null;
    this.publish("history", "refresh");
    this.publish("beam", "refresh")
  }

  escape(text) { // Clean up text to remove html formatting characters
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");
  }

  randomName() {
    return emoji[Math.floor(Math.random() * emoji.length)]
  }

}

// BeamModel.register("BeamModel");
croquet.model = new BeamModel()
croquet.model.init()

class BeamView {

  constructor(model) {
    // super(model);
    this.model = model;
    croquet.view = this
    this.recall = []
    this.nextdownload = null
    // textIn.addEventListener('keydown', (event) => {if(event.keyCode==38) {textIn.value = this.recall.pop()||''}})
    // sendButton.onclick = () => {this.send(textIn.value); textIn.value = "";};
    // this.subscribe("history", "refresh", this.refreshHistory);
    // this.subscribe("viewInfo", "refresh", this.refreshViewInfo);
    // this.subscribe("beam", "refresh", this.refreshBeam);
    this.refreshHistory();
    this.refreshViewInfo();
    this.refreshBeam()
    beam.addEventListener('keydown',this.narrowBeam)
    beam.addEventListener('keyup',this.narrowBeam)
    // loginButton.addEventListener('click', event => this.newFace(this,event))

    // if (model.participants === 1 &&
    //   !model.history.find(item => item.viewId === this.viewId)) {
    //   this.publish("input", "reset", "for new user");
    // }
    // const m = document.cookie.match(/\bface=(\d+)\b/)
    // if (m) this.publish('input','newName',{viewId:this.viewId, nickname:emoji[+m[1]]})
  }

  // send(text) {
  //   if (text.startsWith('/')) this.recall.push(text)
  //   if (text === "/reset") {
  //     this.publish("input", "reset", "at user request");
  //   } else
  //   if (text === "/remove") {
  //     const indices = [...window.beamlist.querySelectorAll('input[type=checkbox]:checked')]
  //       .map(e => +e.value)
  //     window.target.innerHTML = ''
  //     this.publish("input", "remove", indices)
  //   } else
  //   if (text.match(/^\/remove (\d+)$/)) {
  //     const last = this.beam().length-1
  //     const count = Math.min(+text.match(/^\/remove (\d+)$/)[1],last+1)
  //     const first = last-(count-1)
  //     const indices = [...Array(last+1).keys()].slice(first)
  //     console.log({count,last,first,indices})
  //     window.target.innerHTML = ''
  //     this.publish("input", "remove", indices)
  //   } else
  //   if (text === "/download") {
  //     if (this.nextdownload) {
  //       download(...this.nextdownload)
  //     } else {
  //       const poems = [...window.beamlist.querySelectorAll('input[type=checkbox]:checked')]
  //         .map(e => this.beam()[+e.value])
  //       const poem = composite(poems)
  //       const filename = poems
  //         .map(poem => poem.name.replace(/[^a-zA-Z0-9]/g,''))
  //         .filter(uniq).sort().join('-') + '.graph.json'
  //       download(poem.graph.stringify(null,2),filename,'application/json')
  //     }
  //   } else
  //   if (text === "/cypher") {
  //     const poems = [...window.beamlist.querySelectorAll('input[type=checkbox]:checked')]
  //       .map(e => this.beam()[+e.value])
  //     const poem = composite(poems)
  //     const cypher = becypher(poem.graph)
  //     const filename = poems
  //       .map(poem => poem.name.replace(/[^a-zA-Z0-9]/g,''))
  //       .filter(uniq).sort().join('-') + '.cypher'
  //     download(cypher,filename,'application/x-cypher')
  //   } else
  //   if (text === "/export") {
  //     const stream = this.beam().map(item => JSON.stringify(item)).join("\n")
  //     const date = new Date().toISOString().split('T')[0]
  //     download(stream,`${date}Z.jsonl`,'application/json')
  //   } else
  //   if (text === "/schema") {
  //     const poems = [...window.beamlist.querySelectorAll('input[type=checkbox]:checked')]
  //       .map(e => this.beam()[+e.value])
  //     const nodes = []
  //     const rels = []
  //     const newnid = n => {
  //       let nid = nodes.findIndex(node => node.type === n.type)
  //       if (nid == -1) {
  //         nid = nodes.length
  //         nodes.push({type:n.type,in:[],out:[],props:{}})
  //       }
  //       for (const key of Object.keys(n.props)) {nodes[nid].props[key]=''}
  //       return nid
  //     }
  //     const newrid = (r,from,to) => {
  //       let rid = rels.findIndex(rel => rel.type === r.type)
  //       if (rid == -1) {
  //         rid = rels.length
  //         rels.push({type:r.type,from,to,props:{}})
  //       }
  //       for (const key of Object.keys(r.props)) {rels[rid].props[key]=''}
  //       return rid
  //     }
  //     for (const poem of poems) {
  //       for (const rel of poem.graph.rels) {
  //         const f = newnid(poem.graph.nodes[rel.from])
  //         const t = newnid(poem.graph.nodes[rel.to])
  //         const r = newrid(rel,f,t)
  //         nodes[f].out.push(r)
  //         nodes[t].in.push(r)
  //       }
  //     }
  //     this.nextdownload = [new Graph(nodes,rels).stringify(null,2),'target.schema.json', 'application/json']
  //     const tip = props => Object.entries(props).map(e => `${e[0]}: ${e[1]}`).join("\n")
  //     const dotn = nodes
  //       .map(node => `"${node.type}" [tooltip="${tip(node.props)}"]`)
  //     const dotr = rels
  //       .map(rel => `"${nodes[rel.from].type}" -> "${nodes[rel.to].type}" [label="${rel.type}" labeltooltip="${tip(rel.props)}"]`)
  //     const dot = ['node [shape=box style=filled fillcolor=palegreen]',...dotn, ...dotr]
  //     hpccWasm.graphviz.layout(`digraph {${dot.join("\n")}}`, "svg", "dot").then(svg => {
  //       target.innerHTML = svg;
  //     })
  //   } else
  //   if (text.startsWith("/match")) {
  //     const tree = cypher.parse(text.slice(1))
  //     if(!tree[0][0]) {
  //       return setTimeout(() => {window.textIn.value = `/${cypher.left}`},100)
  //     }
  //     const code = cypher.gen(0,tree[0][0],{})
  //     const inputs = [...window.beam.querySelectorAll('input[type=checkbox]')]
  //     this.model.beam.forEach((poem,i) => {
  //       inputs[i].checked = !!(cypher.apply(poem.graph,code).length)
  //     })
  //     window.dochoose({})
  //   }
  //   this.publish("input", "newPost", {viewId: this.viewId, nick:'system', chat:text});
  // }

  newPoems(poems) {
    poems.forEach(poem => poem.date = Date.now())
    // this.publish("input", "newPoems", poems)
    croquet.model.addToBeam(poems)
  }

  updatePoem(index, graph, suffix) {
    this.publish("input", "updatePoem", {index,graph,suffix})
  }

  refreshViewInfo() {
    // console.log('users', this.model.participants, 'at', new Date().toLocaleTimeString())
    // members.innerText = [...this.model.views.values()].join(" ")
  }

  refreshHistory() {
    // textOut.innerHTML = this.model.history
    //   .map(item => `${item.nick}: ${item.chat}`).join("<br>");
    // textOut.scrollIntoView({behavior: "smooth", block: "end", inline: "nearest"})
  }

  refreshBeam() {
    const now = (new Date).getTime()
    const sections = [
      {date: now-1000*60*60*24*365*100, period: 'Years'},
      {date: now-1000*60*60*24*365, period: 'a Year'},
      {date: now-1000*60*60*24*91, period: 'a Season'},
      {date: now-1000*60*60*24*7*31, period: 'a Month'},
      {date: now-1000*60*60*24*7, period: 'a Week'},
      {date: now-1000*60*60*24, period: 'a Day'},
      {date: now-1000*60*60, period: 'an Hour'},
      {date: now-1000*60, period: 'a Minute'},
      {date: now, period: 'Seconds'}
    ]

    this.nextdownload = null
    const want = [...window.beamlist.querySelectorAll('input[type=checkbox]:checked')]
      .map(e => +e.value)
    console.log('refreshBeam',want)
    // if (!want.length) window.dochoose({})
    const names = this.model.beam.map(poem => poem.name || poem.graph.nodes[0].type)
    let then = 1
    window.beamlist.innerHTML = names
      .map((n,i) => {
        const poem = this.model.beam[i]
        let sep = ''
        for (const section of sections) {
          if (then && poem.date && then<section.date && poem.date>=section.date) {
            sep = `<div><font color=gray>Within ${section.period}</font></div>`
          }
        }
        then = poem.date || 1
        const hover = poem.date ? `title="${new Date(poem.date).toLocaleString()}"` : ''
        const number = `<sup>${poem.graph.nodes.length}</sup>`
        return `${sep}<div><font color=gray size=1>${i}</font>
        <input type=checkbox value=${i} id=n${i} ${want.includes(i)?'checked':''}>
        <label for=n${i} ${hover}>${n}${number}</label></div>`
      })
      .join("\n")
    const last = window.beamlist.querySelector('div:last-of-type')
    if(last) last.scrollIntoView({behavior: "smooth", block: "end", inline: "nearest"})
  }

  narrowBeam(event) {
    if(event.key === 'Shift') {
      const items = window.beamlist.querySelectorAll('input[type=checkbox]')
      const checked = window.beamlist.querySelectorAll('input[type=checkbox]:checked')
      if (event.type==='keydown' && checked.length) {
        items.forEach(item => {
          if(!item.checked && item.nextElementSibling.style.color != 'darkorange')
            item.parentElement.style.display='none'
        })
      } else {
        items.forEach(item => {
          item.parentElement.style.display='block'
        })
      }
    }
  }

  newFace(view, event) {
    const face = Math.floor(Math.random() * emoji.length)
    document.cookie = `face=${face};samesite`
    view.publish('input','newName',{viewId:this.viewId, nickname:emoji[face]})
  }

  beam() {
    return this.model.beam
  }
}

function download(string, file, mime='text/json') {
  var data = `data:${mime};charset=utf-8,` + encodeURIComponent(string)
  var anchor = document.createElement('a')
  anchor.setAttribute("href", data)
  anchor.setAttribute("download", file)
  document.body.appendChild(anchor) // required for firefox
  anchor.click()
  anchor.remove()
}

croquet.view = new BeamView(croquet.model)

function addLines (text) {
  text.trim().split(/\n/).forEach(async line => {
    const {name,graph} = JSON.parse(line)
    croquet.view.newPoems([{name,graph:inst(graph)}])
    await delay(60)
  })
}

const params = new URLSearchParams(location.search)
for(const [param,string] of params) {
  switch (param) {
    case 'read':
      addLines(await fetch(string).then(res => res.text()))
      break
    case 'add':
      addLines(atob(string))
      break
    default:
      console.log("Can't handle param named", param)/URLSearchParams
  }
}

</script>
</body>
</html>
